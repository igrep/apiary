{-# LANGUAGE NoMonomorphismRestriction #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE Rank2Types #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE FlexibleContexts #-}

{-
module Web.Apiary.Database.Persist
    ( Migrator(..), With, Persist
    -- * initializer
    , persist,     persistNoLog,     persist'
    , persistPool, persistPoolNoLog, persistPool'
    -- * query
    , runSql
    -- * filter
    , sql
    ) where
-}
import Data.Pool
import Control.Monad
import Control.Monad.Logger
import Control.Monad.Reader
import Control.Monad.Trans.Resource

import Database.Persist.Sql

import Web.Apiary
import Web.Apiary.Logger
import Data.Apiary.SList
import Data.Apiary.Proxy
import Data.Apiary.Document
import Data.Apiary.Extension
import Data.Apiary.Extension.Internal
import Control.Monad.Apiary.Filter.Internal

data Migrator
    = Logging Migration
    | Silent  Migration
    | Unsafe  Migration
    | NoMigrate

data Persist
    = PersistPool ConnectionPool
    | PersistConn Connection

type With c m = forall a. (c -> m a) -> m a

initPersist' :: (MonadIO m, MonadBaseControl IO m)
             => With Connection m -> Migrator -> Initializer es m (Persist ': es)
initPersist' with migr = Initializer $ \e -> with $ \conn -> do
    -- doMigration migr conn
    return $ addExtension (PersistConn conn) e

initPersist :: (MonadIO m, MonadBaseControl IO m, Has Logger exts)
            => With Connection (LogWrapper exts m) -> Migration
            -> Initializer exts m (Persist ': exts)
initPersist w m = Initializer $ \e -> runLogWrapper e $
    unInitializer (initPersist' w $ Logging m) e

initPersistNoLog :: (MonadIO m, MonadBaseControl IO m)
                 => With Connection (NoLoggingT m)
                 -> Migration -> Initializer es m (Persist ': es)
initPersistNoLog w m = Initializer $ \e ->
    runNoLoggingT $ unInitializer (initPersist' w $ Silent m) e

--initPersistPool' :: (MonadIO m, MonadBaseControl IO m)
--                 => With ConnectionPool m -> Migrator
--                 -> Initializer es m (Persist ': es)
initPersistPool' :: (MonadIO m, MonadBaseControl IO m)
                 => (forall a. Extensions exts -> n a -> m a)
                 -> With ConnectionPool n
                 -> Migrator
                 -> Initializer exts m (Persist ': exts)
initPersistPool' run with migr = Initializer $ \e ->
    run e $ with $ \pool -> do
    -- withResource pool $ doMigration migr
    return $ addExtension (PersistPool pool) e


{-
initPersistPool' run with migr = Initializer $ \e -> with $ \pool -> do
    -- withResource pool $ doMigration migr
    run $ addExtension (PersistPool pool) e

initPersistPool' :: (MonadIO m, MonadBaseControl IO m)
                 => With ConnectionPool m -> Migrator
                 -> Initializer es m (Persist ': es)
initPersistPool' with migr = Initializer $ \e -> with $ \pool -> do
    -- withResource pool $ doMigration migr
    return $ addExtension (PersistPool pool) e

initPersistPool :: (MonadIO m, MonadBaseControl IO m, Has Logger exts)
                => With ConnectionPool (LogWrapper exts m) -> Migration
                -> Initializer exts m (Persist ': exts)
initPersistPool w m = Initializer $ \e -> runLogWrapper e $
    unInitializer (initPersistPool' w $ Logging m) e

persistPoolNoLog :: (MonadIO m, MonadBaseControl IO m)
                 => With ConnectionPool (NoLoggingT m) -> Migration -> Initializer es m (Persist ': es)
persistPoolNoLog w m = Initializer $ \e -> runNoLoggingT $ unInitializer (persistPool' w $ Silent m) e

doMigration :: (MonadIO m, MonadBaseControl IO m) => Migrator -> Connection -> m ()
doMigration migr conn = case migr of
    Logging m -> runReaderT (runMigration m) conn
    Silent  m -> runReaderT (void (runMigrationSilent m)) conn
    Unsafe  m -> runReaderT (runMigrationUnsafe m) conn
    NoMigrate -> return ()

runSql :: (Has Persist exts, MonadBaseControl IO m)
       => SqlPersistT (ActionT exts m) a -> ActionT exts m a
runSql a = getExt (Proxy :: Proxy Persist) >>= \case
    PersistPool p -> runSqlPool a p
    PersistConn c -> runSqlConn a c

-- | filter by sql query. since 0.9.0.0.
sql :: (Has Persist exts, MonadBaseControl IO actM)
    => Maybe Html
    -> SqlPersistT (ActionT exts actM) a
    -> (a -> Maybe b) -- ^ result check function. Nothing: fail filter, Just a: success filter and add parameter.
    -> ApiaryT exts (b ': prms) actM m () -> ApiaryT exts prms actM m ()
sql doc q p = focus (maybe id DocPrecondition doc) $ \l ->
    fmap p (runSql q) >>= \case
        Nothing -> mzero
        Just a  -> return (a ::: l)
        -}
